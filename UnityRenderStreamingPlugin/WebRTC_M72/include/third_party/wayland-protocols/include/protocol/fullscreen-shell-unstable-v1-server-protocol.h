/* Generated by wayland-scanner 1.14.0 */

#ifndef FULLSCREEN_SHELL_UNSTABLE_V1_SERVER_PROTOCOL_H
#define FULLSCREEN_SHELL_UNSTABLE_V1_SERVER_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-server.h"

#ifdef  __cplusplus
extern "C" {
#endif

struct wl_client;
struct wl_resource;

/**
 * @page page_fullscreen_shell_unstable_v1 The fullscreen_shell_unstable_v1 protocol
 * @section page_ifaces_fullscreen_shell_unstable_v1 Interfaces
 * - @subpage page_iface_zwp_fullscreen_shell_v1 - displays a single surface per output
 * - @subpage page_iface_zwp_fullscreen_shell_mode_feedback_v1 - 
 */
struct wl_output;
struct wl_surface;
struct zwp_fullscreen_shell_mode_feedback_v1;
struct zwp_fullscreen_shell_v1;

/**
 * @page page_iface_zwp_fullscreen_shell_v1 zwp_fullscreen_shell_v1
 * @section page_iface_zwp_fullscreen_shell_v1_desc Description
 *
 * Displays a single surface per output.
 *
 * This interface provides a mechanism for a single client to display
 * simple full-screen surfaces.  While there technically may be multiple
 * clients bound to this interface, only one of those clients should be
 * shown at a time.
 *
 * To present a surface, the client uses either the present_surface or
 * present_surface_for_mode requests.  Presenting a surface takes effect
 * on the next wl_surface.commit.  See the individual requests for
 * details about scaling and mode switches.
 *
 * The client can have at most one surface per output at any time.
 * Requesting a surface to be presented on an output that already has a
 * surface replaces the previously presented surface.  Presenting a null
 * surface removes its content and effectively disables the output.
 * Exactly what happens when an output is "disabled" is
 * compositor-specific.  The same surface may be presented on multiple
 * outputs simultaneously.
 *
 * Once a surface is presented on an output, it stays on that output
 * until either the client removes it or the compositor destroys the
 * output.  This way, the client can update the output's contents by
 * simply attaching a new buffer.
 *
 * Warning! The protocol described in this file is experimental and
 * backward incompatible changes may be made. Backward compatible changes
 * may be added together with the corresponding interface version bump.
 * Backward incompatible changes are done by bumping the version number in
 * the protocol and interface names and resetting the interface version.
 * Once the protocol is to be declared stable, the 'z' prefix and the
 * version number in the protocol and interface names are removed and the
 * interface version number is reset.
 * @section page_iface_zwp_fullscreen_shell_v1_api API
 * See @ref iface_zwp_fullscreen_shell_v1.
 */
/**
 * @defgroup iface_zwp_fullscreen_shell_v1 The zwp_fullscreen_shell_v1 interface
 *
 * Displays a single surface per output.
 *
 * This interface provides a mechanism for a single client to display
 * simple full-screen surfaces.  While there technically may be multiple
 * clients bound to this interface, only one of those clients should be
 * shown at a time.
 *
 * To present a surface, the client uses either the present_surface or
 * present_surface_for_mode requests.  Presenting a surface takes effect
 * on the next wl_surface.commit.  See the individual requests for
 * details about scaling and mode switches.
 *
 * The client can have at most one surface per output at any time.
 * Requesting a surface to be presented on an output that already has a
 * surface replaces the previously presented surface.  Presenting a null
 * surface removes its content and effectively disables the output.
 * Exactly what happens when an output is "disabled" is
 * compositor-specific.  The same surface may be presented on multiple
 * outputs simultaneously.
 *
 * Once a surface is presented on an output, it stays on that output
 * until either the client removes it or the compositor destroys the
 * output.  This way, the client can update the output's contents by
 * simply attaching a new buffer.
 *
 * Warning! The protocol described in this file is experimental and
 * backward incompatible changes may be made. Backward compatible changes
 * may be added together with the corresponding interface version bump.
 * Backward incompatible changes are done by bumping the version number in
 * the protocol and interface names and resetting the interface version.
 * Once the protocol is to be declared stable, the 'z' prefix and the
 * version number in the protocol and interface names are removed and the
 * interface version number is reset.
 */
extern const struct wl_interface zwp_fullscreen_shell_v1_interface;
/**
 * @page page_iface_zwp_fullscreen_shell_mode_feedback_v1 zwp_fullscreen_shell_mode_feedback_v1
 * @section page_iface_zwp_fullscreen_shell_mode_feedback_v1_api API
 * See @ref iface_zwp_fullscreen_shell_mode_feedback_v1.
 */
/**
 * @defgroup iface_zwp_fullscreen_shell_mode_feedback_v1 The zwp_fullscreen_shell_mode_feedback_v1 interface
 */
extern const struct wl_interface zwp_fullscreen_shell_mode_feedback_v1_interface;

#ifndef ZWP_FULLSCREEN_SHELL_V1_CAPABILITY_ENUM
#define ZWP_FULLSCREEN_SHELL_V1_CAPABILITY_ENUM
/**
 * @ingroup iface_zwp_fullscreen_shell_v1
 * capabilities advertised by the compositor
 *
 * Various capabilities that can be advertised by the compositor.  They
 * are advertised one-at-a-time when the wl_fullscreen_shell interface is
 * bound.  See the wl_fullscreen_shell.capability event for more details.
 *
 * ARBITRARY_MODES:
 * This is a hint to the client that indicates that the compositor is
 * capable of setting practically any mode on its outputs.  If this
 * capability is provided, wl_fullscreen_shell.present_surface_for_mode
 * will almost never fail and clients should feel free to set whatever
 * mode they like.  If the compositor does not advertise this, it may
 * still support some modes that are not advertised through wl_global.mode
 * but it is less likely.
 *
 * CURSOR_PLANE:
 * This is a hint to the client that indicates that the compositor can
 * handle a cursor surface from the client without actually compositing.
 * This may be because of a hardware cursor plane or some other mechanism.
 * If the compositor does not advertise this capability then setting
 * wl_pointer.cursor may degrade performance or be ignored entirely.  If
 * CURSOR_PLANE is not advertised, it is recommended that the client draw
 * its own cursor and set wl_pointer.cursor(NULL).
 */
enum zwp_fullscreen_shell_v1_capability {
	/**
	 * compositor is capable of almost any output mode
	 */
	ZWP_FULLSCREEN_SHELL_V1_CAPABILITY_ARBITRARY_MODES = 1,
	/**
	 * compositor has a separate cursor plane
	 */
	ZWP_FULLSCREEN_SHELL_V1_CAPABILITY_CURSOR_PLANE = 2,
};
#endif /* ZWP_FULLSCREEN_SHELL_V1_CAPABILITY_ENUM */

#ifndef ZWP_FULLSCREEN_SHELL_V1_PRESENT_METHOD_ENUM
#define ZWP_FULLSCREEN_SHELL_V1_PRESENT_METHOD_ENUM
/**
 * @ingroup iface_zwp_fullscreen_shell_v1
 * different method to set the surface fullscreen
 *
 * Hints to indicate to the compositor how to deal with a conflict
 * between the dimensions of the surface and the dimensions of the
 * output. The compositor is free to ignore this parameter.
 */
enum zwp_fullscreen_shell_v1_present_method {
	/**
	 * no preference, apply default policy
	 */
	ZWP_FULLSCREEN_SHELL_V1_PRESENT_METHOD_DEFAULT = 0,
	/**
	 * center the surface on the output
	 */
	ZWP_FULLSCREEN_SHELL_V1_PRESENT_METHOD_CENTER = 1,
	/**
	 * scale the surface, preserving aspect ratio, to the largest size that will fit on the output
	 */
	ZWP_FULLSCREEN_SHELL_V1_PRESENT_METHOD_ZOOM = 2,
	/**
	 * scale the surface, preserving aspect ratio, to fully fill the output cropping if needed
	 */
	ZWP_FULLSCREEN_SHELL_V1_PRESENT_METHOD_ZOOM_CROP = 3,
	/**
	 * scale the surface to the size of the output ignoring aspect ratio
	 */
	ZWP_FULLSCREEN_SHELL_V1_PRESENT_METHOD_STRETCH = 4,
};
#endif /* ZWP_FULLSCREEN_SHELL_V1_PRESENT_METHOD_ENUM */

#ifndef ZWP_FULLSCREEN_SHELL_V1_ERROR_ENUM
#define ZWP_FULLSCREEN_SHELL_V1_ERROR_ENUM
/**
 * @ingroup iface_zwp_fullscreen_shell_v1
 * wl_fullscreen_shell error values
 *
 * These errors can be emitted in response to wl_fullscreen_shell requests.
 */
enum zwp_fullscreen_shell_v1_error {
	/**
	 * present_method is not known
	 */
	ZWP_FULLSCREEN_SHELL_V1_ERROR_INVALID_METHOD = 0,
};
#endif /* ZWP_FULLSCREEN_SHELL_V1_ERROR_ENUM */

/**
 * @ingroup iface_zwp_fullscreen_shell_v1
 * @struct zwp_fullscreen_shell_v1_interface
 */
struct zwp_fullscreen_shell_v1_interface {
	/**
	 * release the wl_fullscreen_shell interface
	 *
	 * Release the binding from the wl_fullscreen_shell interface.
	 *
	 * This destroys the server-side object and frees this binding. If
	 * the client binds to wl_fullscreen_shell multiple times, it may
	 * wish to free some of those bindings.
	 */
	void (*release)(struct wl_client *client,
			struct wl_resource *resource);
	/**
	 * present surface for display
	 *
	 * Present a surface on the given output.
	 *
	 * If the output is null, the compositor will present the surface
	 * on whatever display (or displays) it thinks best. In particular,
	 * this may replace any or all surfaces currently presented so it
	 * should not be used in combination with placing surfaces on
	 * specific outputs.
	 *
	 * The method parameter is a hint to the compositor for how the
	 * surface is to be presented. In particular, it tells the
	 * compositor how to handle a size mismatch between the presented
	 * surface and the output. The compositor is free to ignore this
	 * parameter.
	 *
	 * The "zoom", "zoom_crop", and "stretch" methods imply a scaling
	 * operation on the surface. This will override any kind of output
	 * scaling, so the buffer_scale property of the surface is
	 * effectively ignored.
	 */
	void (*present_surface)(struct wl_client *client,
				struct wl_resource *resource,
				struct wl_resource *surface,
				uint32_t method,
				struct wl_resource *output);
	/**
	 * present surface for display at a particular mode
	 *
	 * Presents a surface on the given output for a particular mode.
	 *
	 * If the current size of the output differs from that of the
	 * surface, the compositor will attempt to change the size of the
	 * output to match the surface. The result of the mode-switch
	 * operation will be returned via the provided
	 * wl_fullscreen_shell_mode_feedback object.
	 *
	 * If the current output mode matches the one requested or if the
	 * compositor successfully switches the mode to match the surface,
	 * then the mode_successful event will be sent and the output will
	 * contain the contents of the given surface. If the compositor
	 * cannot match the output size to the surface size, the
	 * mode_failed will be sent and the output will contain the
	 * contents of the previously presented surface (if any). If
	 * another surface is presented on the given output before either
	 * of these has a chance to happen, the present_cancelled event
	 * will be sent.
	 *
	 * Due to race conditions and other issues unknown to the client,
	 * no mode-switch operation is guaranteed to succeed. However, if
	 * the mode is one advertised by wl_output.mode or if the
	 * compositor advertises the ARBITRARY_MODES capability, then the
	 * client should expect that the mode-switch operation will usually
	 * succeed.
	 *
	 * If the size of the presented surface changes, the resulting
	 * output is undefined. The compositor may attempt to change the
	 * output mode to compensate. However, there is no guarantee that a
	 * suitable mode will be found and the client has no way to be
	 * notified of success or failure.
	 *
	 * The framerate parameter specifies the desired framerate for the
	 * output in mHz. The compositor is free to ignore this parameter.
	 * A value of 0 indicates that the client has no preference.
	 *
	 * If the value of wl_output.scale differs from
	 * wl_surface.buffer_scale, then the compositor may choose a mode
	 * that matches either the buffer size or the surface size. In
	 * either case, the surface will fill the output.
	 */
	void (*present_surface_for_mode)(struct wl_client *client,
					 struct wl_resource *resource,
					 struct wl_resource *surface,
					 struct wl_resource *output,
					 int32_t framerate,
					 uint32_t feedback);
};

#define ZWP_FULLSCREEN_SHELL_V1_CAPABILITY 0

/**
 * @ingroup iface_zwp_fullscreen_shell_v1
 */
#define ZWP_FULLSCREEN_SHELL_V1_CAPABILITY_SINCE_VERSION 1

/**
 * @ingroup iface_zwp_fullscreen_shell_v1
 */
#define ZWP_FULLSCREEN_SHELL_V1_RELEASE_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_fullscreen_shell_v1
 */
#define ZWP_FULLSCREEN_SHELL_V1_PRESENT_SURFACE_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_fullscreen_shell_v1
 */
#define ZWP_FULLSCREEN_SHELL_V1_PRESENT_SURFACE_FOR_MODE_SINCE_VERSION 1

/**
 * @ingroup iface_zwp_fullscreen_shell_v1
 * Sends an capability event to the client owning the resource.
 * @param resource_ The client's resource
 */
static inline void
zwp_fullscreen_shell_v1_send_capability(struct wl_resource *resource_, uint32_t capability)
{
	wl_resource_post_event(resource_, ZWP_FULLSCREEN_SHELL_V1_CAPABILITY, capability);
}

#define ZWP_FULLSCREEN_SHELL_MODE_FEEDBACK_V1_MODE_SUCCESSFUL 0
#define ZWP_FULLSCREEN_SHELL_MODE_FEEDBACK_V1_MODE_FAILED 1
#define ZWP_FULLSCREEN_SHELL_MODE_FEEDBACK_V1_PRESENT_CANCELLED 2

/**
 * @ingroup iface_zwp_fullscreen_shell_mode_feedback_v1
 */
#define ZWP_FULLSCREEN_SHELL_MODE_FEEDBACK_V1_MODE_SUCCESSFUL_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_fullscreen_shell_mode_feedback_v1
 */
#define ZWP_FULLSCREEN_SHELL_MODE_FEEDBACK_V1_MODE_FAILED_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_fullscreen_shell_mode_feedback_v1
 */
#define ZWP_FULLSCREEN_SHELL_MODE_FEEDBACK_V1_PRESENT_CANCELLED_SINCE_VERSION 1


/**
 * @ingroup iface_zwp_fullscreen_shell_mode_feedback_v1
 * Sends an mode_successful event to the client owning the resource.
 * @param resource_ The client's resource
 */
static inline void
zwp_fullscreen_shell_mode_feedback_v1_send_mode_successful(struct wl_resource *resource_)
{
	wl_resource_post_event(resource_, ZWP_FULLSCREEN_SHELL_MODE_FEEDBACK_V1_MODE_SUCCESSFUL);
}

/**
 * @ingroup iface_zwp_fullscreen_shell_mode_feedback_v1
 * Sends an mode_failed event to the client owning the resource.
 * @param resource_ The client's resource
 */
static inline void
zwp_fullscreen_shell_mode_feedback_v1_send_mode_failed(struct wl_resource *resource_)
{
	wl_resource_post_event(resource_, ZWP_FULLSCREEN_SHELL_MODE_FEEDBACK_V1_MODE_FAILED);
}

/**
 * @ingroup iface_zwp_fullscreen_shell_mode_feedback_v1
 * Sends an present_cancelled event to the client owning the resource.
 * @param resource_ The client's resource
 */
static inline void
zwp_fullscreen_shell_mode_feedback_v1_send_present_cancelled(struct wl_resource *resource_)
{
	wl_resource_post_event(resource_, ZWP_FULLSCREEN_SHELL_MODE_FEEDBACK_V1_PRESENT_CANCELLED);
}

#ifdef  __cplusplus
}
#endif

#endif
