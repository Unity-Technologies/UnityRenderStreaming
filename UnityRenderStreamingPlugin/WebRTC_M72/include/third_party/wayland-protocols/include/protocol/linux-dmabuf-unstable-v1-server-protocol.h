/* Generated by wayland-scanner 1.13.0 */

#ifndef LINUX_DMABUF_UNSTABLE_V1_SERVER_PROTOCOL_H
#define LINUX_DMABUF_UNSTABLE_V1_SERVER_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-server.h"

#ifdef  __cplusplus
extern "C" {
#endif

struct wl_client;
struct wl_resource;

/**
 * @page page_linux_dmabuf_unstable_v1 The linux_dmabuf_unstable_v1 protocol
 * @section page_ifaces_linux_dmabuf_unstable_v1 Interfaces
 * - @subpage page_iface_zwp_linux_dmabuf_v1 - factory for creating dmabuf-based wl_buffers
 * - @subpage page_iface_zwp_linux_buffer_params_v1 - parameters for creating a dmabuf-based wl_buffer
 * @section page_copyright_linux_dmabuf_unstable_v1 Copyright
 * <pre>
 *
 * Copyright Â© 2014, 2015 Collabora, Ltd.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * </pre>
 */
struct wl_buffer;
struct zwp_linux_buffer_params_v1;
struct zwp_linux_dmabuf_v1;

/**
 * @page page_iface_zwp_linux_dmabuf_v1 zwp_linux_dmabuf_v1
 * @section page_iface_zwp_linux_dmabuf_v1_desc Description
 *
 * Following the interfaces from:
 * https://www.khronos.org/registry/egl/extensions/EXT/EGL_EXT_image_dma_buf_import.txt
 * and the Linux DRM sub-system's AddFb2 ioctl.
 *
 * This interface offers ways to create generic dmabuf-based
 * wl_buffers. Immediately after a client binds to this interface,
 * the set of supported formats and format modifiers is sent with
 * 'format' and 'modifier' events.
 *
 * The following are required from clients:
 *
 * - Clients must ensure that either all data in the dma-buf is
 * coherent for all subsequent read access or that coherency is
 * correctly handled by the underlying kernel-side dma-buf
 * implementation.
 *
 * - Don't make any more attachments after sending the buffer to the
 * compositor. Making more attachments later increases the risk of
 * the compositor not being able to use (re-import) an existing
 * dmabuf-based wl_buffer.
 *
 * The underlying graphics stack must ensure the following:
 *
 * - The dmabuf file descriptors relayed to the server will stay valid
 * for the whole lifetime of the wl_buffer. This means the server may
 * at any time use those fds to import the dmabuf into any kernel
 * sub-system that might accept it.
 *
 * To create a wl_buffer from one or more dmabufs, a client creates a
 * zwp_linux_dmabuf_params_v1 object with a zwp_linux_dmabuf_v1.create_params
 * request. All planes required by the intended format are added with
 * the 'add' request. Finally, a 'create' or 'create_immed' request is
 * issued, which has the following outcome depending on the import success.
 *
 * The 'create' request,
 * - on success, triggers a 'created' event which provides the final
 * wl_buffer to the client.
 * - on failure, triggers a 'failed' event to convey that the server
 * cannot use the dmabufs received from the client.
 *
 * For the 'create_immed' request,
 * - on success, the server immediately imports the added dmabufs to
 * create a wl_buffer. No event is sent from the server in this case.
 * - on failure, the server can choose to either:
 * - terminate the client by raising a fatal error.
 * - mark the wl_buffer as failed, and send a 'failed' event to the
 * client. If the client uses a failed wl_buffer as an argument to any
 * request, the behaviour is compositor implementation-defined.
 *
 * Warning! The protocol described in this file is experimental and
 * backward incompatible changes may be made. Backward compatible changes
 * may be added together with the corresponding interface version bump.
 * Backward incompatible changes are done by bumping the version number in
 * the protocol and interface names and resetting the interface version.
 * Once the protocol is to be declared stable, the 'z' prefix and the
 * version number in the protocol and interface names are removed and the
 * interface version number is reset.
 * @section page_iface_zwp_linux_dmabuf_v1_api API
 * See @ref iface_zwp_linux_dmabuf_v1.
 */
/**
 * @defgroup iface_zwp_linux_dmabuf_v1 The zwp_linux_dmabuf_v1 interface
 *
 * Following the interfaces from:
 * https://www.khronos.org/registry/egl/extensions/EXT/EGL_EXT_image_dma_buf_import.txt
 * and the Linux DRM sub-system's AddFb2 ioctl.
 *
 * This interface offers ways to create generic dmabuf-based
 * wl_buffers. Immediately after a client binds to this interface,
 * the set of supported formats and format modifiers is sent with
 * 'format' and 'modifier' events.
 *
 * The following are required from clients:
 *
 * - Clients must ensure that either all data in the dma-buf is
 * coherent for all subsequent read access or that coherency is
 * correctly handled by the underlying kernel-side dma-buf
 * implementation.
 *
 * - Don't make any more attachments after sending the buffer to the
 * compositor. Making more attachments later increases the risk of
 * the compositor not being able to use (re-import) an existing
 * dmabuf-based wl_buffer.
 *
 * The underlying graphics stack must ensure the following:
 *
 * - The dmabuf file descriptors relayed to the server will stay valid
 * for the whole lifetime of the wl_buffer. This means the server may
 * at any time use those fds to import the dmabuf into any kernel
 * sub-system that might accept it.
 *
 * To create a wl_buffer from one or more dmabufs, a client creates a
 * zwp_linux_dmabuf_params_v1 object with a zwp_linux_dmabuf_v1.create_params
 * request. All planes required by the intended format are added with
 * the 'add' request. Finally, a 'create' or 'create_immed' request is
 * issued, which has the following outcome depending on the import success.
 *
 * The 'create' request,
 * - on success, triggers a 'created' event which provides the final
 * wl_buffer to the client.
 * - on failure, triggers a 'failed' event to convey that the server
 * cannot use the dmabufs received from the client.
 *
 * For the 'create_immed' request,
 * - on success, the server immediately imports the added dmabufs to
 * create a wl_buffer. No event is sent from the server in this case.
 * - on failure, the server can choose to either:
 * - terminate the client by raising a fatal error.
 * - mark the wl_buffer as failed, and send a 'failed' event to the
 * client. If the client uses a failed wl_buffer as an argument to any
 * request, the behaviour is compositor implementation-defined.
 *
 * Warning! The protocol described in this file is experimental and
 * backward incompatible changes may be made. Backward compatible changes
 * may be added together with the corresponding interface version bump.
 * Backward incompatible changes are done by bumping the version number in
 * the protocol and interface names and resetting the interface version.
 * Once the protocol is to be declared stable, the 'z' prefix and the
 * version number in the protocol and interface names are removed and the
 * interface version number is reset.
 */
extern const struct wl_interface zwp_linux_dmabuf_v1_interface;
/**
 * @page page_iface_zwp_linux_buffer_params_v1 zwp_linux_buffer_params_v1
 * @section page_iface_zwp_linux_buffer_params_v1_desc Description
 *
 * This temporary object is a collection of dmabufs and other
 * parameters that together form a single logical buffer. The temporary
 * object may eventually create one wl_buffer unless cancelled by
 * destroying it before requesting 'create'.
 *
 * Single-planar formats only require one dmabuf, however
 * multi-planar formats may require more than one dmabuf. For all
 * formats, an 'add' request must be called once per plane (even if the
 * underlying dmabuf fd is identical).
 *
 * You must use consecutive plane indices ('plane_idx' argument for 'add')
 * from zero to the number of planes used by the drm_fourcc format code.
 * All planes required by the format must be given exactly once, but can
 * be given in any order. Each plane index can be set only once.
 * @section page_iface_zwp_linux_buffer_params_v1_api API
 * See @ref iface_zwp_linux_buffer_params_v1.
 */
/**
 * @defgroup iface_zwp_linux_buffer_params_v1 The zwp_linux_buffer_params_v1 interface
 *
 * This temporary object is a collection of dmabufs and other
 * parameters that together form a single logical buffer. The temporary
 * object may eventually create one wl_buffer unless cancelled by
 * destroying it before requesting 'create'.
 *
 * Single-planar formats only require one dmabuf, however
 * multi-planar formats may require more than one dmabuf. For all
 * formats, an 'add' request must be called once per plane (even if the
 * underlying dmabuf fd is identical).
 *
 * You must use consecutive plane indices ('plane_idx' argument for 'add')
 * from zero to the number of planes used by the drm_fourcc format code.
 * All planes required by the format must be given exactly once, but can
 * be given in any order. Each plane index can be set only once.
 */
extern const struct wl_interface zwp_linux_buffer_params_v1_interface;

/**
 * @ingroup iface_zwp_linux_dmabuf_v1
 * @struct zwp_linux_dmabuf_v1_interface
 */
struct zwp_linux_dmabuf_v1_interface {
	/**
	 * unbind the factory
	 *
	 * Objects created through this interface, especially wl_buffers,
	 * will remain valid.
	 */
	void (*destroy)(struct wl_client *client,
			struct wl_resource *resource);
	/**
	 * create a temporary object for buffer parameters
	 *
	 * This temporary object is used to collect multiple dmabuf
	 * handles into a single batch to create a wl_buffer. It can only
	 * be used once and should be destroyed after a 'created' or
	 * 'failed' event has been received.
	 * @param params_id the new temporary
	 */
	void (*create_params)(struct wl_client *client,
			      struct wl_resource *resource,
			      uint32_t params_id);
};

#define ZWP_LINUX_DMABUF_V1_FORMAT 0
#define ZWP_LINUX_DMABUF_V1_MODIFIER 1

/**
 * @ingroup iface_zwp_linux_dmabuf_v1
 */
#define ZWP_LINUX_DMABUF_V1_FORMAT_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_linux_dmabuf_v1
 */
#define ZWP_LINUX_DMABUF_V1_MODIFIER_SINCE_VERSION 3

/**
 * @ingroup iface_zwp_linux_dmabuf_v1
 */
#define ZWP_LINUX_DMABUF_V1_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_linux_dmabuf_v1
 */
#define ZWP_LINUX_DMABUF_V1_CREATE_PARAMS_SINCE_VERSION 1

/**
 * @ingroup iface_zwp_linux_dmabuf_v1
 * Sends an format event to the client owning the resource.
 * @param resource_ The client's resource
 * @param format DRM_FORMAT code
 */
static inline void
zwp_linux_dmabuf_v1_send_format(struct wl_resource *resource_, uint32_t format)
{
	wl_resource_post_event(resource_, ZWP_LINUX_DMABUF_V1_FORMAT, format);
}

/**
 * @ingroup iface_zwp_linux_dmabuf_v1
 * Sends an modifier event to the client owning the resource.
 * @param resource_ The client's resource
 * @param format DRM_FORMAT code
 * @param modifier_hi high 32 bits of layout modifier
 * @param modifier_lo low 32 bits of layout modifier
 */
static inline void
zwp_linux_dmabuf_v1_send_modifier(struct wl_resource *resource_, uint32_t format, uint32_t modifier_hi, uint32_t modifier_lo)
{
	wl_resource_post_event(resource_, ZWP_LINUX_DMABUF_V1_MODIFIER, format, modifier_hi, modifier_lo);
}

#ifndef ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_ENUM
#define ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_ENUM
enum zwp_linux_buffer_params_v1_error {
	/**
	 * the dmabuf_batch object has already been used to create a wl_buffer
	 */
	ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_ALREADY_USED = 0,
	/**
	 * plane index out of bounds
	 */
	ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_PLANE_IDX = 1,
	/**
	 * the plane index was already set
	 */
	ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_PLANE_SET = 2,
	/**
	 * missing or too many planes to create a buffer
	 */
	ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_INCOMPLETE = 3,
	/**
	 * format not supported
	 */
	ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_INVALID_FORMAT = 4,
	/**
	 * invalid width or height
	 */
	ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_INVALID_DIMENSIONS = 5,
	/**
	 * offset + stride * height goes out of dmabuf bounds
	 */
	ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_OUT_OF_BOUNDS = 6,
	/**
	 * invalid wl_buffer resulted from importing dmabufs via                the create_immed request on given buffer_params
	 */
	ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_INVALID_WL_BUFFER = 7,
};
#endif /* ZWP_LINUX_BUFFER_PARAMS_V1_ERROR_ENUM */

#ifndef ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_ENUM
#define ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_ENUM
enum zwp_linux_buffer_params_v1_flags {
	/**
	 * contents are y-inverted
	 */
	ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_Y_INVERT = 1,
	/**
	 * content is interlaced
	 */
	ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_INTERLACED = 2,
	/**
	 * bottom field first
	 */
	ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_BOTTOM_FIRST = 4,
};
#endif /* ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_ENUM */

/**
 * @ingroup iface_zwp_linux_buffer_params_v1
 * @struct zwp_linux_buffer_params_v1_interface
 */
struct zwp_linux_buffer_params_v1_interface {
	/**
	 * delete this object, used or not
	 *
	 * Cleans up the temporary data sent to the server for
	 * dmabuf-based wl_buffer creation.
	 */
	void (*destroy)(struct wl_client *client,
			struct wl_resource *resource);
	/**
	 * add a dmabuf to the temporary set
	 *
	 * This request adds one dmabuf to the set in this
	 * zwp_linux_buffer_params_v1.
	 *
	 * The 64-bit unsigned value combined from modifier_hi and
	 * modifier_lo is the dmabuf layout modifier. DRM AddFB2 ioctl
	 * calls this the fb modifier, which is defined in drm_mode.h of
	 * Linux UAPI. This is an opaque token. Drivers use this token to
	 * express tiling, compression, etc. driver-specific modifications
	 * to the base format defined by the DRM fourcc code.
	 *
	 * This request raises the PLANE_IDX error if plane_idx is too
	 * large. The error PLANE_SET is raised if attempting to set a
	 * plane that was already set.
	 * @param fd dmabuf fd
	 * @param plane_idx plane index
	 * @param offset offset in bytes
	 * @param stride stride in bytes
	 * @param modifier_hi high 32 bits of layout modifier
	 * @param modifier_lo low 32 bits of layout modifier
	 */
	void (*add)(struct wl_client *client,
		    struct wl_resource *resource,
		    int32_t fd,
		    uint32_t plane_idx,
		    uint32_t offset,
		    uint32_t stride,
		    uint32_t modifier_hi,
		    uint32_t modifier_lo);
	/**
	 * create a wl_buffer from the given dmabufs
	 *
	 * This asks for creation of a wl_buffer from the added dmabuf
	 * buffers. The wl_buffer is not created immediately but returned
	 * via the 'created' event if the dmabuf sharing succeeds. The
	 * sharing may fail at runtime for reasons a client cannot predict,
	 * in which case the 'failed' event is triggered.
	 *
	 * The 'format' argument is a DRM_FORMAT code, as defined by the
	 * libdrm's drm_fourcc.h. The Linux kernel's DRM sub-system is the
	 * authoritative source on how the format codes should work.
	 *
	 * The 'flags' is a bitfield of the flags defined in enum "flags".
	 * 'y_invert' means the that the image needs to be y-flipped.
	 *
	 * Flag 'interlaced' means that the frame in the buffer is not
	 * progressive as usual, but interlaced. An interlaced buffer as
	 * supported here must always contain both top and bottom fields.
	 * The top field always begins on the first pixel row. The temporal
	 * ordering between the two fields is top field first, unless
	 * 'bottom_first' is specified. It is undefined whether
	 * 'bottom_first' is ignored if 'interlaced' is not set.
	 *
	 * This protocol does not convey any information about field rate,
	 * duration, or timing, other than the relative ordering between
	 * the two fields in one buffer. A compositor may have to estimate
	 * the intended field rate from the incoming buffer rate. It is
	 * undefined whether the time of receiving wl_surface.commit with a
	 * new buffer attached, applying the wl_surface state,
	 * wl_surface.frame callback trigger, presentation, or any other
	 * point in the compositor cycle is used to measure the frame or
	 * field times. There is no support for detecting missed or late
	 * frames/fields/buffers either, and there is no support whatsoever
	 * for cooperating with interlaced compositor output.
	 *
	 * The composited image quality resulting from the use of
	 * interlaced buffers is explicitly undefined. A compositor may use
	 * elaborate hardware features or software to deinterlace and
	 * create progressive output frames from a sequence of interlaced
	 * input buffers, or it may produce substandard image quality.
	 * However, compositors that cannot guarantee reasonable image
	 * quality in all cases are recommended to just reject all
	 * interlaced buffers.
	 *
	 * Any argument errors, including non-positive width or height,
	 * mismatch between the number of planes and the format, bad
	 * format, bad offset or stride, may be indicated by fatal protocol
	 * errors: INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS,
	 * OUT_OF_BOUNDS.
	 *
	 * Dmabuf import errors in the server that are not obvious client
	 * bugs are returned via the 'failed' event as non-fatal. This
	 * allows attempting dmabuf sharing and falling back in the client
	 * if it fails.
	 *
	 * This request can be sent only once in the object's lifetime,
	 * after which the only legal request is destroy. This object
	 * should be destroyed after issuing a 'create' request. Attempting
	 * to use this object after issuing 'create' raises ALREADY_USED
	 * protocol error.
	 *
	 * It is not mandatory to issue 'create'. If a client wants to
	 * cancel the buffer creation, it can just destroy this object.
	 * @param width base plane width in pixels
	 * @param height base plane height in pixels
	 * @param format DRM_FORMAT code
	 * @param flags see enum flags
	 */
	void (*create)(struct wl_client *client,
		       struct wl_resource *resource,
		       int32_t width,
		       int32_t height,
		       uint32_t format,
		       uint32_t flags);
	/**
	 * immediately create a wl_buffer from the given                      dmabufs
	 *
	 * This asks for immediate creation of a wl_buffer by importing
	 * the added dmabufs.
	 *
	 * In case of import success, no event is sent from the server, and
	 * the wl_buffer is ready to be used by the client.
	 *
	 * Upon import failure, either of the following may happen, as seen
	 * fit by the implementation: - the client is terminated with one
	 * of the following fatal protocol errors: - INCOMPLETE,
	 * INVALID_FORMAT, INVALID_DIMENSIONS, OUT_OF_BOUNDS, in case of
	 * argument errors such as mismatch between the number of planes
	 * and the format, bad format, non-positive width or height, or bad
	 * offset or stride. - INVALID_WL_BUFFER, in case the cause for
	 * failure is unknown or plaform specific. - the server creates an
	 * invalid wl_buffer, marks it as failed and sends a 'failed' event
	 * to the client. The result of using this invalid wl_buffer as an
	 * argument in any request by the client is defined by the
	 * compositor implementation.
	 *
	 * This takes the same arguments as a 'create' request, and obeys
	 * the same restrictions.
	 * @param buffer_id id for the newly created wl_buffer
	 * @param width base plane width in pixels
	 * @param height base plane height in pixels
	 * @param format DRM_FORMAT code
	 * @param flags see enum flags
	 * @since 2
	 */
	void (*create_immed)(struct wl_client *client,
			     struct wl_resource *resource,
			     uint32_t buffer_id,
			     int32_t width,
			     int32_t height,
			     uint32_t format,
			     uint32_t flags);
};

#define ZWP_LINUX_BUFFER_PARAMS_V1_CREATED 0
#define ZWP_LINUX_BUFFER_PARAMS_V1_FAILED 1

/**
 * @ingroup iface_zwp_linux_buffer_params_v1
 */
#define ZWP_LINUX_BUFFER_PARAMS_V1_CREATED_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_linux_buffer_params_v1
 */
#define ZWP_LINUX_BUFFER_PARAMS_V1_FAILED_SINCE_VERSION 1

/**
 * @ingroup iface_zwp_linux_buffer_params_v1
 */
#define ZWP_LINUX_BUFFER_PARAMS_V1_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_linux_buffer_params_v1
 */
#define ZWP_LINUX_BUFFER_PARAMS_V1_ADD_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_linux_buffer_params_v1
 */
#define ZWP_LINUX_BUFFER_PARAMS_V1_CREATE_SINCE_VERSION 1
/**
 * @ingroup iface_zwp_linux_buffer_params_v1
 */
#define ZWP_LINUX_BUFFER_PARAMS_V1_CREATE_IMMED_SINCE_VERSION 2

/**
 * @ingroup iface_zwp_linux_buffer_params_v1
 * Sends an created event to the client owning the resource.
 * @param resource_ The client's resource
 * @param buffer the newly created wl_buffer
 */
static inline void
zwp_linux_buffer_params_v1_send_created(struct wl_resource *resource_, struct wl_resource *buffer)
{
	wl_resource_post_event(resource_, ZWP_LINUX_BUFFER_PARAMS_V1_CREATED, buffer);
}

/**
 * @ingroup iface_zwp_linux_buffer_params_v1
 * Sends an failed event to the client owning the resource.
 * @param resource_ The client's resource
 */
static inline void
zwp_linux_buffer_params_v1_send_failed(struct wl_resource *resource_)
{
	wl_resource_post_event(resource_, ZWP_LINUX_BUFFER_PARAMS_V1_FAILED);
}

#ifdef  __cplusplus
}
#endif

#endif
