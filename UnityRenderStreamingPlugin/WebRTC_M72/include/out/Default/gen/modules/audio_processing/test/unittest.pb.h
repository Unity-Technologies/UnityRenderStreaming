// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: unittest.proto

#ifndef PROTOBUF_INCLUDED_unittest_2eproto
#define PROTOBUF_INCLUDED_unittest_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_unittest_2eproto 

namespace protobuf_unittest_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
}  // namespace protobuf_unittest_2eproto
namespace webrtc {
namespace audioproc {
class OutputData;
class OutputDataDefaultTypeInternal;
extern OutputDataDefaultTypeInternal _OutputData_default_instance_;
class Test;
class TestDefaultTypeInternal;
extern TestDefaultTypeInternal _Test_default_instance_;
class Test_DelayMetrics;
class Test_DelayMetricsDefaultTypeInternal;
extern Test_DelayMetricsDefaultTypeInternal _Test_DelayMetrics_default_instance_;
class Test_EchoMetrics;
class Test_EchoMetricsDefaultTypeInternal;
extern Test_EchoMetricsDefaultTypeInternal _Test_EchoMetrics_default_instance_;
class Test_Frame;
class Test_FrameDefaultTypeInternal;
extern Test_FrameDefaultTypeInternal _Test_Frame_default_instance_;
}  // namespace audioproc
}  // namespace webrtc
namespace google {
namespace protobuf {
template<> ::webrtc::audioproc::OutputData* Arena::CreateMaybeMessage<::webrtc::audioproc::OutputData>(Arena*);
template<> ::webrtc::audioproc::Test* Arena::CreateMaybeMessage<::webrtc::audioproc::Test>(Arena*);
template<> ::webrtc::audioproc::Test_DelayMetrics* Arena::CreateMaybeMessage<::webrtc::audioproc::Test_DelayMetrics>(Arena*);
template<> ::webrtc::audioproc::Test_EchoMetrics* Arena::CreateMaybeMessage<::webrtc::audioproc::Test_EchoMetrics>(Arena*);
template<> ::webrtc::audioproc::Test_Frame* Arena::CreateMaybeMessage<::webrtc::audioproc::Test_Frame>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace webrtc {
namespace audioproc {

// ===================================================================

class Test_Frame : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audioproc.Test.Frame) */ {
 public:
  Test_Frame();
  virtual ~Test_Frame();

  Test_Frame(const Test_Frame& from);

  inline Test_Frame& operator=(const Test_Frame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Test_Frame(Test_Frame&& from) noexcept
    : Test_Frame() {
    *this = ::std::move(from);
  }

  inline Test_Frame& operator=(Test_Frame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Test_Frame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Test_Frame* internal_default_instance() {
    return reinterpret_cast<const Test_Frame*>(
               &_Test_Frame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(Test_Frame* other);
  friend void swap(Test_Frame& a, Test_Frame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Test_Frame* New() const final {
    return CreateMaybeMessage<Test_Frame>(NULL);
  }

  Test_Frame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Test_Frame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Test_Frame& from);
  void MergeFrom(const Test_Frame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Test_Frame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:webrtc.audioproc.Test.Frame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_unittest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Test_EchoMetrics : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audioproc.Test.EchoMetrics) */ {
 public:
  Test_EchoMetrics();
  virtual ~Test_EchoMetrics();

  Test_EchoMetrics(const Test_EchoMetrics& from);

  inline Test_EchoMetrics& operator=(const Test_EchoMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Test_EchoMetrics(Test_EchoMetrics&& from) noexcept
    : Test_EchoMetrics() {
    *this = ::std::move(from);
  }

  inline Test_EchoMetrics& operator=(Test_EchoMetrics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Test_EchoMetrics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Test_EchoMetrics* internal_default_instance() {
    return reinterpret_cast<const Test_EchoMetrics*>(
               &_Test_EchoMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(Test_EchoMetrics* other);
  friend void swap(Test_EchoMetrics& a, Test_EchoMetrics& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Test_EchoMetrics* New() const final {
    return CreateMaybeMessage<Test_EchoMetrics>(NULL);
  }

  Test_EchoMetrics* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Test_EchoMetrics>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Test_EchoMetrics& from);
  void MergeFrom(const Test_EchoMetrics& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Test_EchoMetrics* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float echo_return_loss = 1;
  bool has_echo_return_loss() const;
  void clear_echo_return_loss();
  static const int kEchoReturnLossFieldNumber = 1;
  float echo_return_loss() const;
  void set_echo_return_loss(float value);

  // optional float echo_return_loss_enhancement = 2;
  bool has_echo_return_loss_enhancement() const;
  void clear_echo_return_loss_enhancement();
  static const int kEchoReturnLossEnhancementFieldNumber = 2;
  float echo_return_loss_enhancement() const;
  void set_echo_return_loss_enhancement(float value);

  // optional float divergent_filter_fraction = 3;
  bool has_divergent_filter_fraction() const;
  void clear_divergent_filter_fraction();
  static const int kDivergentFilterFractionFieldNumber = 3;
  float divergent_filter_fraction() const;
  void set_divergent_filter_fraction(float value);

  // optional float residual_echo_likelihood = 4;
  bool has_residual_echo_likelihood() const;
  void clear_residual_echo_likelihood();
  static const int kResidualEchoLikelihoodFieldNumber = 4;
  float residual_echo_likelihood() const;
  void set_residual_echo_likelihood(float value);

  // optional float residual_echo_likelihood_recent_max = 5;
  bool has_residual_echo_likelihood_recent_max() const;
  void clear_residual_echo_likelihood_recent_max();
  static const int kResidualEchoLikelihoodRecentMaxFieldNumber = 5;
  float residual_echo_likelihood_recent_max() const;
  void set_residual_echo_likelihood_recent_max(float value);

  // @@protoc_insertion_point(class_scope:webrtc.audioproc.Test.EchoMetrics)
 private:
  void set_has_echo_return_loss();
  void clear_has_echo_return_loss();
  void set_has_echo_return_loss_enhancement();
  void clear_has_echo_return_loss_enhancement();
  void set_has_divergent_filter_fraction();
  void clear_has_divergent_filter_fraction();
  void set_has_residual_echo_likelihood();
  void clear_has_residual_echo_likelihood();
  void set_has_residual_echo_likelihood_recent_max();
  void clear_has_residual_echo_likelihood_recent_max();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float echo_return_loss_;
  float echo_return_loss_enhancement_;
  float divergent_filter_fraction_;
  float residual_echo_likelihood_;
  float residual_echo_likelihood_recent_max_;
  friend struct ::protobuf_unittest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Test_DelayMetrics : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audioproc.Test.DelayMetrics) */ {
 public:
  Test_DelayMetrics();
  virtual ~Test_DelayMetrics();

  Test_DelayMetrics(const Test_DelayMetrics& from);

  inline Test_DelayMetrics& operator=(const Test_DelayMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Test_DelayMetrics(Test_DelayMetrics&& from) noexcept
    : Test_DelayMetrics() {
    *this = ::std::move(from);
  }

  inline Test_DelayMetrics& operator=(Test_DelayMetrics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Test_DelayMetrics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Test_DelayMetrics* internal_default_instance() {
    return reinterpret_cast<const Test_DelayMetrics*>(
               &_Test_DelayMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(Test_DelayMetrics* other);
  friend void swap(Test_DelayMetrics& a, Test_DelayMetrics& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Test_DelayMetrics* New() const final {
    return CreateMaybeMessage<Test_DelayMetrics>(NULL);
  }

  Test_DelayMetrics* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Test_DelayMetrics>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Test_DelayMetrics& from);
  void MergeFrom(const Test_DelayMetrics& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Test_DelayMetrics* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 median = 1;
  bool has_median() const;
  void clear_median();
  static const int kMedianFieldNumber = 1;
  ::google::protobuf::int32 median() const;
  void set_median(::google::protobuf::int32 value);

  // optional int32 std = 2;
  bool has_std() const;
  void clear_std();
  static const int kStdFieldNumber = 2;
  ::google::protobuf::int32 std() const;
  void set_std(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:webrtc.audioproc.Test.DelayMetrics)
 private:
  void set_has_median();
  void clear_has_median();
  void set_has_std();
  void clear_has_std();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 median_;
  ::google::protobuf::int32 std_;
  friend struct ::protobuf_unittest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Test : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audioproc.Test) */ {
 public:
  Test();
  virtual ~Test();

  Test(const Test& from);

  inline Test& operator=(const Test& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Test(Test&& from) noexcept
    : Test() {
    *this = ::std::move(from);
  }

  inline Test& operator=(Test&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Test& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Test* internal_default_instance() {
    return reinterpret_cast<const Test*>(
               &_Test_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(Test* other);
  friend void swap(Test& a, Test& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Test* New() const final {
    return CreateMaybeMessage<Test>(NULL);
  }

  Test* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Test>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Test& from);
  void MergeFrom(const Test& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Test* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Test_Frame Frame;
  typedef Test_EchoMetrics EchoMetrics;
  typedef Test_DelayMetrics DelayMetrics;

  // accessors -------------------------------------------------------

  // repeated .webrtc.audioproc.Test.Frame frame = 5;
  int frame_size() const;
  void clear_frame();
  static const int kFrameFieldNumber = 5;
  ::webrtc::audioproc::Test_Frame* mutable_frame(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_Frame >*
      mutable_frame();
  const ::webrtc::audioproc::Test_Frame& frame(int index) const;
  ::webrtc::audioproc::Test_Frame* add_frame();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_Frame >&
      frame() const;

  // repeated .webrtc.audioproc.Test.EchoMetrics echo_metrics = 11;
  int echo_metrics_size() const;
  void clear_echo_metrics();
  static const int kEchoMetricsFieldNumber = 11;
  ::webrtc::audioproc::Test_EchoMetrics* mutable_echo_metrics(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_EchoMetrics >*
      mutable_echo_metrics();
  const ::webrtc::audioproc::Test_EchoMetrics& echo_metrics(int index) const;
  ::webrtc::audioproc::Test_EchoMetrics* add_echo_metrics();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_EchoMetrics >&
      echo_metrics() const;

  // repeated .webrtc.audioproc.Test.DelayMetrics delay_metrics = 12;
  int delay_metrics_size() const;
  void clear_delay_metrics();
  static const int kDelayMetricsFieldNumber = 12;
  ::webrtc::audioproc::Test_DelayMetrics* mutable_delay_metrics(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_DelayMetrics >*
      mutable_delay_metrics();
  const ::webrtc::audioproc::Test_DelayMetrics& delay_metrics(int index) const;
  ::webrtc::audioproc::Test_DelayMetrics* add_delay_metrics();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_DelayMetrics >&
      delay_metrics() const;

  // repeated int32 rms_level = 13;
  int rms_level_size() const;
  void clear_rms_level();
  static const int kRmsLevelFieldNumber = 13;
  ::google::protobuf::int32 rms_level(int index) const;
  void set_rms_level(int index, ::google::protobuf::int32 value);
  void add_rms_level(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      rms_level() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_rms_level();

  // optional int32 num_reverse_channels = 1;
  bool has_num_reverse_channels() const;
  void clear_num_reverse_channels();
  static const int kNumReverseChannelsFieldNumber = 1;
  ::google::protobuf::int32 num_reverse_channels() const;
  void set_num_reverse_channels(::google::protobuf::int32 value);

  // optional int32 num_input_channels = 2;
  bool has_num_input_channels() const;
  void clear_num_input_channels();
  static const int kNumInputChannelsFieldNumber = 2;
  ::google::protobuf::int32 num_input_channels() const;
  void set_num_input_channels(::google::protobuf::int32 value);

  // optional int32 num_output_channels = 3;
  bool has_num_output_channels() const;
  void clear_num_output_channels();
  static const int kNumOutputChannelsFieldNumber = 3;
  ::google::protobuf::int32 num_output_channels() const;
  void set_num_output_channels(::google::protobuf::int32 value);

  // optional int32 sample_rate = 4;
  bool has_sample_rate() const;
  void clear_sample_rate();
  static const int kSampleRateFieldNumber = 4;
  ::google::protobuf::int32 sample_rate() const;
  void set_sample_rate(::google::protobuf::int32 value);

  // optional int32 analog_level_average = 6;
  bool has_analog_level_average() const;
  void clear_analog_level_average();
  static const int kAnalogLevelAverageFieldNumber = 6;
  ::google::protobuf::int32 analog_level_average() const;
  void set_analog_level_average(::google::protobuf::int32 value);

  // optional int32 max_output_average = 7;
  bool has_max_output_average() const;
  void clear_max_output_average();
  static const int kMaxOutputAverageFieldNumber = 7;
  ::google::protobuf::int32 max_output_average() const;
  void set_max_output_average(::google::protobuf::int32 value);

  // optional int32 has_voice_count = 9;
  bool has_has_voice_count() const;
  void clear_has_voice_count();
  static const int kHasVoiceCountFieldNumber = 9;
  ::google::protobuf::int32 has_voice_count() const;
  void set_has_voice_count(::google::protobuf::int32 value);

  // optional int32 is_saturated_count = 10;
  bool has_is_saturated_count() const;
  void clear_is_saturated_count();
  static const int kIsSaturatedCountFieldNumber = 10;
  ::google::protobuf::int32 is_saturated_count() const;
  void set_is_saturated_count(::google::protobuf::int32 value);

  // optional float ns_speech_probability_average = 14;
  bool has_ns_speech_probability_average() const;
  void clear_ns_speech_probability_average();
  static const int kNsSpeechProbabilityAverageFieldNumber = 14;
  float ns_speech_probability_average() const;
  void set_ns_speech_probability_average(float value);

  // optional bool use_aec_extended_filter = 15;
  bool has_use_aec_extended_filter() const;
  void clear_use_aec_extended_filter();
  static const int kUseAecExtendedFilterFieldNumber = 15;
  bool use_aec_extended_filter() const;
  void set_use_aec_extended_filter(bool value);

  // @@protoc_insertion_point(class_scope:webrtc.audioproc.Test)
 private:
  void set_has_num_reverse_channels();
  void clear_has_num_reverse_channels();
  void set_has_num_input_channels();
  void clear_has_num_input_channels();
  void set_has_num_output_channels();
  void clear_has_num_output_channels();
  void set_has_sample_rate();
  void clear_has_sample_rate();
  void set_has_analog_level_average();
  void clear_has_analog_level_average();
  void set_has_max_output_average();
  void clear_has_max_output_average();
  void set_has_has_voice_count();
  void clear_has_has_voice_count();
  void set_has_is_saturated_count();
  void clear_has_is_saturated_count();
  void set_has_ns_speech_probability_average();
  void clear_has_ns_speech_probability_average();
  void set_has_use_aec_extended_filter();
  void clear_has_use_aec_extended_filter();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_Frame > frame_;
  ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_EchoMetrics > echo_metrics_;
  ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_DelayMetrics > delay_metrics_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > rms_level_;
  ::google::protobuf::int32 num_reverse_channels_;
  ::google::protobuf::int32 num_input_channels_;
  ::google::protobuf::int32 num_output_channels_;
  ::google::protobuf::int32 sample_rate_;
  ::google::protobuf::int32 analog_level_average_;
  ::google::protobuf::int32 max_output_average_;
  ::google::protobuf::int32 has_voice_count_;
  ::google::protobuf::int32 is_saturated_count_;
  float ns_speech_probability_average_;
  bool use_aec_extended_filter_;
  friend struct ::protobuf_unittest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OutputData : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audioproc.OutputData) */ {
 public:
  OutputData();
  virtual ~OutputData();

  OutputData(const OutputData& from);

  inline OutputData& operator=(const OutputData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OutputData(OutputData&& from) noexcept
    : OutputData() {
    *this = ::std::move(from);
  }

  inline OutputData& operator=(OutputData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const OutputData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OutputData* internal_default_instance() {
    return reinterpret_cast<const OutputData*>(
               &_OutputData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(OutputData* other);
  friend void swap(OutputData& a, OutputData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OutputData* New() const final {
    return CreateMaybeMessage<OutputData>(NULL);
  }

  OutputData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OutputData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const OutputData& from);
  void MergeFrom(const OutputData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OutputData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .webrtc.audioproc.Test test = 1;
  int test_size() const;
  void clear_test();
  static const int kTestFieldNumber = 1;
  ::webrtc::audioproc::Test* mutable_test(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test >*
      mutable_test();
  const ::webrtc::audioproc::Test& test(int index) const;
  ::webrtc::audioproc::Test* add_test();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test >&
      test() const;

  // @@protoc_insertion_point(class_scope:webrtc.audioproc.OutputData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test > test_;
  friend struct ::protobuf_unittest_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Test_Frame

// -------------------------------------------------------------------

// Test_EchoMetrics

// optional float echo_return_loss = 1;
inline bool Test_EchoMetrics::has_echo_return_loss() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Test_EchoMetrics::set_has_echo_return_loss() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Test_EchoMetrics::clear_has_echo_return_loss() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Test_EchoMetrics::clear_echo_return_loss() {
  echo_return_loss_ = 0;
  clear_has_echo_return_loss();
}
inline float Test_EchoMetrics::echo_return_loss() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.EchoMetrics.echo_return_loss)
  return echo_return_loss_;
}
inline void Test_EchoMetrics::set_echo_return_loss(float value) {
  set_has_echo_return_loss();
  echo_return_loss_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.EchoMetrics.echo_return_loss)
}

// optional float echo_return_loss_enhancement = 2;
inline bool Test_EchoMetrics::has_echo_return_loss_enhancement() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Test_EchoMetrics::set_has_echo_return_loss_enhancement() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Test_EchoMetrics::clear_has_echo_return_loss_enhancement() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Test_EchoMetrics::clear_echo_return_loss_enhancement() {
  echo_return_loss_enhancement_ = 0;
  clear_has_echo_return_loss_enhancement();
}
inline float Test_EchoMetrics::echo_return_loss_enhancement() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.EchoMetrics.echo_return_loss_enhancement)
  return echo_return_loss_enhancement_;
}
inline void Test_EchoMetrics::set_echo_return_loss_enhancement(float value) {
  set_has_echo_return_loss_enhancement();
  echo_return_loss_enhancement_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.EchoMetrics.echo_return_loss_enhancement)
}

// optional float divergent_filter_fraction = 3;
inline bool Test_EchoMetrics::has_divergent_filter_fraction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Test_EchoMetrics::set_has_divergent_filter_fraction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Test_EchoMetrics::clear_has_divergent_filter_fraction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Test_EchoMetrics::clear_divergent_filter_fraction() {
  divergent_filter_fraction_ = 0;
  clear_has_divergent_filter_fraction();
}
inline float Test_EchoMetrics::divergent_filter_fraction() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.EchoMetrics.divergent_filter_fraction)
  return divergent_filter_fraction_;
}
inline void Test_EchoMetrics::set_divergent_filter_fraction(float value) {
  set_has_divergent_filter_fraction();
  divergent_filter_fraction_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.EchoMetrics.divergent_filter_fraction)
}

// optional float residual_echo_likelihood = 4;
inline bool Test_EchoMetrics::has_residual_echo_likelihood() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Test_EchoMetrics::set_has_residual_echo_likelihood() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Test_EchoMetrics::clear_has_residual_echo_likelihood() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Test_EchoMetrics::clear_residual_echo_likelihood() {
  residual_echo_likelihood_ = 0;
  clear_has_residual_echo_likelihood();
}
inline float Test_EchoMetrics::residual_echo_likelihood() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.EchoMetrics.residual_echo_likelihood)
  return residual_echo_likelihood_;
}
inline void Test_EchoMetrics::set_residual_echo_likelihood(float value) {
  set_has_residual_echo_likelihood();
  residual_echo_likelihood_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.EchoMetrics.residual_echo_likelihood)
}

// optional float residual_echo_likelihood_recent_max = 5;
inline bool Test_EchoMetrics::has_residual_echo_likelihood_recent_max() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Test_EchoMetrics::set_has_residual_echo_likelihood_recent_max() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Test_EchoMetrics::clear_has_residual_echo_likelihood_recent_max() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Test_EchoMetrics::clear_residual_echo_likelihood_recent_max() {
  residual_echo_likelihood_recent_max_ = 0;
  clear_has_residual_echo_likelihood_recent_max();
}
inline float Test_EchoMetrics::residual_echo_likelihood_recent_max() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.EchoMetrics.residual_echo_likelihood_recent_max)
  return residual_echo_likelihood_recent_max_;
}
inline void Test_EchoMetrics::set_residual_echo_likelihood_recent_max(float value) {
  set_has_residual_echo_likelihood_recent_max();
  residual_echo_likelihood_recent_max_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.EchoMetrics.residual_echo_likelihood_recent_max)
}

// -------------------------------------------------------------------

// Test_DelayMetrics

// optional int32 median = 1;
inline bool Test_DelayMetrics::has_median() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Test_DelayMetrics::set_has_median() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Test_DelayMetrics::clear_has_median() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Test_DelayMetrics::clear_median() {
  median_ = 0;
  clear_has_median();
}
inline ::google::protobuf::int32 Test_DelayMetrics::median() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.DelayMetrics.median)
  return median_;
}
inline void Test_DelayMetrics::set_median(::google::protobuf::int32 value) {
  set_has_median();
  median_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.DelayMetrics.median)
}

// optional int32 std = 2;
inline bool Test_DelayMetrics::has_std() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Test_DelayMetrics::set_has_std() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Test_DelayMetrics::clear_has_std() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Test_DelayMetrics::clear_std() {
  std_ = 0;
  clear_has_std();
}
inline ::google::protobuf::int32 Test_DelayMetrics::std() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.DelayMetrics.std)
  return std_;
}
inline void Test_DelayMetrics::set_std(::google::protobuf::int32 value) {
  set_has_std();
  std_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.DelayMetrics.std)
}

// -------------------------------------------------------------------

// Test

// optional int32 num_reverse_channels = 1;
inline bool Test::has_num_reverse_channels() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Test::set_has_num_reverse_channels() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Test::clear_has_num_reverse_channels() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Test::clear_num_reverse_channels() {
  num_reverse_channels_ = 0;
  clear_has_num_reverse_channels();
}
inline ::google::protobuf::int32 Test::num_reverse_channels() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.num_reverse_channels)
  return num_reverse_channels_;
}
inline void Test::set_num_reverse_channels(::google::protobuf::int32 value) {
  set_has_num_reverse_channels();
  num_reverse_channels_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.num_reverse_channels)
}

// optional int32 num_input_channels = 2;
inline bool Test::has_num_input_channels() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Test::set_has_num_input_channels() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Test::clear_has_num_input_channels() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Test::clear_num_input_channels() {
  num_input_channels_ = 0;
  clear_has_num_input_channels();
}
inline ::google::protobuf::int32 Test::num_input_channels() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.num_input_channels)
  return num_input_channels_;
}
inline void Test::set_num_input_channels(::google::protobuf::int32 value) {
  set_has_num_input_channels();
  num_input_channels_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.num_input_channels)
}

// optional int32 num_output_channels = 3;
inline bool Test::has_num_output_channels() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Test::set_has_num_output_channels() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Test::clear_has_num_output_channels() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Test::clear_num_output_channels() {
  num_output_channels_ = 0;
  clear_has_num_output_channels();
}
inline ::google::protobuf::int32 Test::num_output_channels() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.num_output_channels)
  return num_output_channels_;
}
inline void Test::set_num_output_channels(::google::protobuf::int32 value) {
  set_has_num_output_channels();
  num_output_channels_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.num_output_channels)
}

// optional int32 sample_rate = 4;
inline bool Test::has_sample_rate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Test::set_has_sample_rate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Test::clear_has_sample_rate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Test::clear_sample_rate() {
  sample_rate_ = 0;
  clear_has_sample_rate();
}
inline ::google::protobuf::int32 Test::sample_rate() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.sample_rate)
  return sample_rate_;
}
inline void Test::set_sample_rate(::google::protobuf::int32 value) {
  set_has_sample_rate();
  sample_rate_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.sample_rate)
}

// repeated .webrtc.audioproc.Test.Frame frame = 5;
inline int Test::frame_size() const {
  return frame_.size();
}
inline void Test::clear_frame() {
  frame_.Clear();
}
inline ::webrtc::audioproc::Test_Frame* Test::mutable_frame(int index) {
  // @@protoc_insertion_point(field_mutable:webrtc.audioproc.Test.frame)
  return frame_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_Frame >*
Test::mutable_frame() {
  // @@protoc_insertion_point(field_mutable_list:webrtc.audioproc.Test.frame)
  return &frame_;
}
inline const ::webrtc::audioproc::Test_Frame& Test::frame(int index) const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.frame)
  return frame_.Get(index);
}
inline ::webrtc::audioproc::Test_Frame* Test::add_frame() {
  // @@protoc_insertion_point(field_add:webrtc.audioproc.Test.frame)
  return frame_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_Frame >&
Test::frame() const {
  // @@protoc_insertion_point(field_list:webrtc.audioproc.Test.frame)
  return frame_;
}

// optional int32 analog_level_average = 6;
inline bool Test::has_analog_level_average() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Test::set_has_analog_level_average() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Test::clear_has_analog_level_average() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Test::clear_analog_level_average() {
  analog_level_average_ = 0;
  clear_has_analog_level_average();
}
inline ::google::protobuf::int32 Test::analog_level_average() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.analog_level_average)
  return analog_level_average_;
}
inline void Test::set_analog_level_average(::google::protobuf::int32 value) {
  set_has_analog_level_average();
  analog_level_average_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.analog_level_average)
}

// optional int32 max_output_average = 7;
inline bool Test::has_max_output_average() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Test::set_has_max_output_average() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Test::clear_has_max_output_average() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Test::clear_max_output_average() {
  max_output_average_ = 0;
  clear_has_max_output_average();
}
inline ::google::protobuf::int32 Test::max_output_average() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.max_output_average)
  return max_output_average_;
}
inline void Test::set_max_output_average(::google::protobuf::int32 value) {
  set_has_max_output_average();
  max_output_average_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.max_output_average)
}

// optional int32 has_voice_count = 9;
inline bool Test::has_has_voice_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Test::set_has_has_voice_count() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Test::clear_has_has_voice_count() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Test::clear_has_voice_count() {
  has_voice_count_ = 0;
  clear_has_has_voice_count();
}
inline ::google::protobuf::int32 Test::has_voice_count() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.has_voice_count)
  return has_voice_count_;
}
inline void Test::set_has_voice_count(::google::protobuf::int32 value) {
  set_has_has_voice_count();
  has_voice_count_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.has_voice_count)
}

// optional int32 is_saturated_count = 10;
inline bool Test::has_is_saturated_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Test::set_has_is_saturated_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Test::clear_has_is_saturated_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Test::clear_is_saturated_count() {
  is_saturated_count_ = 0;
  clear_has_is_saturated_count();
}
inline ::google::protobuf::int32 Test::is_saturated_count() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.is_saturated_count)
  return is_saturated_count_;
}
inline void Test::set_is_saturated_count(::google::protobuf::int32 value) {
  set_has_is_saturated_count();
  is_saturated_count_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.is_saturated_count)
}

// repeated .webrtc.audioproc.Test.EchoMetrics echo_metrics = 11;
inline int Test::echo_metrics_size() const {
  return echo_metrics_.size();
}
inline void Test::clear_echo_metrics() {
  echo_metrics_.Clear();
}
inline ::webrtc::audioproc::Test_EchoMetrics* Test::mutable_echo_metrics(int index) {
  // @@protoc_insertion_point(field_mutable:webrtc.audioproc.Test.echo_metrics)
  return echo_metrics_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_EchoMetrics >*
Test::mutable_echo_metrics() {
  // @@protoc_insertion_point(field_mutable_list:webrtc.audioproc.Test.echo_metrics)
  return &echo_metrics_;
}
inline const ::webrtc::audioproc::Test_EchoMetrics& Test::echo_metrics(int index) const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.echo_metrics)
  return echo_metrics_.Get(index);
}
inline ::webrtc::audioproc::Test_EchoMetrics* Test::add_echo_metrics() {
  // @@protoc_insertion_point(field_add:webrtc.audioproc.Test.echo_metrics)
  return echo_metrics_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_EchoMetrics >&
Test::echo_metrics() const {
  // @@protoc_insertion_point(field_list:webrtc.audioproc.Test.echo_metrics)
  return echo_metrics_;
}

// repeated .webrtc.audioproc.Test.DelayMetrics delay_metrics = 12;
inline int Test::delay_metrics_size() const {
  return delay_metrics_.size();
}
inline void Test::clear_delay_metrics() {
  delay_metrics_.Clear();
}
inline ::webrtc::audioproc::Test_DelayMetrics* Test::mutable_delay_metrics(int index) {
  // @@protoc_insertion_point(field_mutable:webrtc.audioproc.Test.delay_metrics)
  return delay_metrics_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_DelayMetrics >*
Test::mutable_delay_metrics() {
  // @@protoc_insertion_point(field_mutable_list:webrtc.audioproc.Test.delay_metrics)
  return &delay_metrics_;
}
inline const ::webrtc::audioproc::Test_DelayMetrics& Test::delay_metrics(int index) const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.delay_metrics)
  return delay_metrics_.Get(index);
}
inline ::webrtc::audioproc::Test_DelayMetrics* Test::add_delay_metrics() {
  // @@protoc_insertion_point(field_add:webrtc.audioproc.Test.delay_metrics)
  return delay_metrics_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_DelayMetrics >&
Test::delay_metrics() const {
  // @@protoc_insertion_point(field_list:webrtc.audioproc.Test.delay_metrics)
  return delay_metrics_;
}

// repeated int32 rms_level = 13;
inline int Test::rms_level_size() const {
  return rms_level_.size();
}
inline void Test::clear_rms_level() {
  rms_level_.Clear();
}
inline ::google::protobuf::int32 Test::rms_level(int index) const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.rms_level)
  return rms_level_.Get(index);
}
inline void Test::set_rms_level(int index, ::google::protobuf::int32 value) {
  rms_level_.Set(index, value);
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.rms_level)
}
inline void Test::add_rms_level(::google::protobuf::int32 value) {
  rms_level_.Add(value);
  // @@protoc_insertion_point(field_add:webrtc.audioproc.Test.rms_level)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Test::rms_level() const {
  // @@protoc_insertion_point(field_list:webrtc.audioproc.Test.rms_level)
  return rms_level_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Test::mutable_rms_level() {
  // @@protoc_insertion_point(field_mutable_list:webrtc.audioproc.Test.rms_level)
  return &rms_level_;
}

// optional float ns_speech_probability_average = 14;
inline bool Test::has_ns_speech_probability_average() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Test::set_has_ns_speech_probability_average() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Test::clear_has_ns_speech_probability_average() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Test::clear_ns_speech_probability_average() {
  ns_speech_probability_average_ = 0;
  clear_has_ns_speech_probability_average();
}
inline float Test::ns_speech_probability_average() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.ns_speech_probability_average)
  return ns_speech_probability_average_;
}
inline void Test::set_ns_speech_probability_average(float value) {
  set_has_ns_speech_probability_average();
  ns_speech_probability_average_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.ns_speech_probability_average)
}

// optional bool use_aec_extended_filter = 15;
inline bool Test::has_use_aec_extended_filter() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Test::set_has_use_aec_extended_filter() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Test::clear_has_use_aec_extended_filter() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Test::clear_use_aec_extended_filter() {
  use_aec_extended_filter_ = false;
  clear_has_use_aec_extended_filter();
}
inline bool Test::use_aec_extended_filter() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.use_aec_extended_filter)
  return use_aec_extended_filter_;
}
inline void Test::set_use_aec_extended_filter(bool value) {
  set_has_use_aec_extended_filter();
  use_aec_extended_filter_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.use_aec_extended_filter)
}

// -------------------------------------------------------------------

// OutputData

// repeated .webrtc.audioproc.Test test = 1;
inline int OutputData::test_size() const {
  return test_.size();
}
inline void OutputData::clear_test() {
  test_.Clear();
}
inline ::webrtc::audioproc::Test* OutputData::mutable_test(int index) {
  // @@protoc_insertion_point(field_mutable:webrtc.audioproc.OutputData.test)
  return test_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test >*
OutputData::mutable_test() {
  // @@protoc_insertion_point(field_mutable_list:webrtc.audioproc.OutputData.test)
  return &test_;
}
inline const ::webrtc::audioproc::Test& OutputData::test(int index) const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.OutputData.test)
  return test_.Get(index);
}
inline ::webrtc::audioproc::Test* OutputData::add_test() {
  // @@protoc_insertion_point(field_add:webrtc.audioproc.OutputData.test)
  return test_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test >&
OutputData::test() const {
  // @@protoc_insertion_point(field_list:webrtc.audioproc.OutputData.test)
  return test_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace audioproc
}  // namespace webrtc

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_unittest_2eproto
